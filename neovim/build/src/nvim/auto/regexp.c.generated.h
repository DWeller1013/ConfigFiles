#define DEFINE_FUNC_ATTRIBUTES
#include "nvim/func_attr.h"
#undef DEFINE_FUNC_ATTRIBUTES
static int no_Magic(int x);
static int toggle_Magic(int x);
static int re_multi_type(int c);
static int backslash_trans(int c);
static int get_char_class(char **pp);
static void init_class_tab(void);
static int get_equi_class(char **pp);
static int get_coll_element(char **pp);
static void get_cpo_flags(void);
static char *skip_anyof(char *p);
static void initchr(char *str);
static void save_parse_state(parse_state_T *ps);
static void restore_parse_state(parse_state_T *ps);
static int peekchr(void);
static void skipchr(void);
static void skipchr_keepstart(void);
static int getchr(void);
static void ungetchr(void);
static int64_t gethexchrs(int maxinputlen);
static int64_t getdecchrs(void);
static int64_t getoctchrs(void);
static int read_limits(int *minval, int *maxval);
static void reg_breakcheck(void);
static _Bool reg_iswordc(int c);
static void reg_getline_common(linenr_T lnum, reg_getline_flags_T flags, char **line, colnr_T *length);
static char *reg_getline(linenr_T lnum);
static colnr_T reg_getline_len(linenr_T lnum);
static reg_extmatch_T *make_extmatch(void) FUNC_ATTR_NONNULL_RET;
static int reg_prev_class(void);
static _Bool reg_match_visual(void);
static int prog_magic_wrong(void);
static void cleanup_subexpr(void);
static void cleanup_zsubexpr(void);
static void reg_nextline(void);
static int match_with_backref(linenr_T start_lnum, colnr_T start_col, linenr_T end_lnum, colnr_T end_col, int *bytelen);
static _Bool re_mult_next(char *what);
static void mb_decompose(int c, int *c1, int *c2, int *c3);
static int cstrncmp(char *s1, char *s2, int *n);
static inline char *cstrchr(const char *const s, const int c) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL FUNC_ATTR_ALWAYS_INLINE;
static void do_upper(int *d, int c);
static void do_lower(int *d, int c);
static int fill_submatch_list(int argc FUNC_ATTR_UNUSED, typval_T *argv, int argskip, ufunc_T *fp) FUNC_ATTR_NONNULL_ALL;
static void clear_submatch_list(staticList10_T *sl);
static int vim_regsub_both(char *source, typval_T *expr, char *dest, int destlen, int flags);
static char *reg_getline_submatch(linenr_T lnum);
static colnr_T reg_getline_submatch_len(linenr_T lnum);
static void init_regexec_multi(regmmatch_T *rmp, win_T *win, buf_T *buf, linenr_T lnum);
static uint8_t *reg(int paren, int *flagp);
static void regcomp_start(uint8_t *expr, int re_flags);
static _Bool use_multibytecode(int c);
static void regc(int b);
static void regmbc(int c);
static void reg_equi_class(int c);
static uint8_t *regnode(int op);
static uint8_t *re_put_uint32(uint8_t *p, uint32_t val);
static uint8_t *regnext(uint8_t *p) FUNC_ATTR_NONNULL_ALL;
static void regtail(uint8_t *p, const uint8_t *val);
static void regoptail(uint8_t *p, uint8_t *val);
static void reginsert(int op, uint8_t *opnd);
static void reginsert_nr(int op, int64_t val, uint8_t *opnd);
static void reginsert_limits(int op, int64_t minval, int64_t maxval, uint8_t *opnd);
static int seen_endbrace(int refnum);
static uint8_t *regatom(int *flagp);
static uint8_t *regpiece(int *flagp);
static uint8_t *regconcat(int *flagp);
static uint8_t *regbranch(int *flagp);
static uint8_t *reg(int paren, int *flagp);
static regprog_T *bt_regcomp(uint8_t *expr, int re_flags);
static int coll_get_char(void);
static void bt_regfree(regprog_T *prog);
static void reg_save(regsave_T *save, garray_T *gap) FUNC_ATTR_NONNULL_ALL;
static void reg_restore(regsave_T *save, garray_T *gap) FUNC_ATTR_NONNULL_ALL;
static _Bool reg_save_equal(const regsave_T *save) FUNC_ATTR_NONNULL_ALL;
static void save_se_multi(save_se_T *savep, lpos_T *posp);
static void save_se_one(save_se_T *savep, uint8_t **pp);
static int regrepeat(uint8_t *p, int64_t maxcount);
static regitem_T *regstack_push(regstate_T state, uint8_t *scan);
static void regstack_pop(uint8_t **scan);
static void save_subexpr(regbehind_T *bp) FUNC_ATTR_NONNULL_ALL;
static void restore_subexpr(regbehind_T *bp) FUNC_ATTR_NONNULL_ALL;
static _Bool regmatch(uint8_t *scan, const proftime_T *tm, int *timed_out);
static int regtry(bt_regprog_T *prog, colnr_T col, proftime_T *tm, int *timed_out);
static int bt_regexec_both(uint8_t *line, colnr_T startcol, proftime_T *tm, int *timed_out);
static int bt_regexec_nl(regmatch_T *rmp, uint8_t *line, colnr_T col, _Bool line_lbr);
static int bt_regexec_multi(regmmatch_T *rmp, win_T *win, buf_T *buf, linenr_T lnum, colnr_T col, proftime_T *tm, int *timed_out);
static int re_num_cmp(uint32_t val, const uint8_t *scan);
static void nfa_regcomp_start(uint8_t *expr, int re_flags);
static int nfa_get_reganch(nfa_state_T *start, int depth);
static int nfa_get_regstart(nfa_state_T *start, int depth);
static uint8_t *nfa_get_match_text(nfa_state_T *start);
static void realloc_post_list(void);
static int nfa_recognize_char_class(uint8_t *start, const uint8_t *end, int extra_newl);
static void nfa_emit_equi_class(int c);
static int nfa_regatom(void);
static int nfa_regpiece(void);
static int nfa_regconcat(void);
static int nfa_regbranch(void);
static int nfa_reg(int paren);
static int *re2post(void);
static nfa_state_T *alloc_state(int c, nfa_state_T *out, nfa_state_T *out1);
static Frag_T frag(nfa_state_T *start, Ptrlist *out);
static Ptrlist *list1(nfa_state_T **outp);
static void patch(Ptrlist *l, nfa_state_T *s);
static Ptrlist *append(Ptrlist *l1, Ptrlist *l2);
static void st_error(int *postfix, int *end, int *p);
static void st_push(Frag_T s, Frag_T **p, Frag_T *stack_end);
static Frag_T st_pop(Frag_T **p, Frag_T *stack);
static int nfa_max_width(nfa_state_T *startstate, int depth);
static nfa_state_T *post2nfa(int *postfix, int *end, int nfa_calc_size);
static void nfa_postprocess(nfa_regprog_T *prog);
static void copy_pim(nfa_pim_T *to, nfa_pim_T *from);
static void clear_sub(regsub_T *sub);
static void copy_sub(regsub_T *to, regsub_T *from);
static void copy_sub_off(regsub_T *to, regsub_T *from);
static void copy_ze_off(regsub_T *to, regsub_T *from);
static _Bool sub_equal(regsub_T *sub1, regsub_T *sub2);
static _Bool has_state_with_pos(nfa_list_T *l, nfa_state_T *state, regsubs_T *subs, nfa_pim_T *pim) FUNC_ATTR_NONNULL_ARG(1, 2, 3);
static _Bool pim_equal(const nfa_pim_T *one, const nfa_pim_T *two);
static _Bool match_follows(const nfa_state_T *startstate, int depth) FUNC_ATTR_NONNULL_ALL;
static _Bool state_in_list(nfa_list_T *l, nfa_state_T *state, regsubs_T *subs) FUNC_ATTR_NONNULL_ALL;
static regsubs_T *addstate(nfa_list_T *l, nfa_state_T *state, regsubs_T *subs_arg, nfa_pim_T *pim, int off_arg) FUNC_ATTR_NONNULL_ARG(1, 2) FUNC_ATTR_WARN_UNUSED_RESULT;
static regsubs_T *addstate_here(nfa_list_T *l, nfa_state_T *state, regsubs_T *subs, nfa_pim_T *pim, int *ip) FUNC_ATTR_NONNULL_ARG(1, 2, 5) FUNC_ATTR_WARN_UNUSED_RESULT;
static int check_char_class(int cls, int c);
static int match_backref(regsub_T *sub, int subidx, int *bytelen);
static int match_zref(int subidx, int *bytelen);
static void nfa_save_listids(nfa_regprog_T *prog, int *list);
static void nfa_restore_listids(nfa_regprog_T *prog, const int *list);
static _Bool nfa_re_num_cmp(uintmax_t val, int op, uintmax_t pos);
static int recursive_regmatch(nfa_state_T *state, nfa_pim_T *pim, nfa_regprog_T *prog, regsubs_T *submatch, regsubs_T *m, int **listids, int *listids_len) FUNC_ATTR_NONNULL_ARG(1, 3, 5, 6, 7);
static int failure_chance(nfa_state_T *state, int depth);
static int skip_to_start(int c, colnr_T *colp);
static int find_match_text(colnr_T *startcol, int regstart, uint8_t *match_text);
static int nfa_did_time_out(void);
static int nfa_regmatch(nfa_regprog_T *prog, nfa_state_T *start, regsubs_T *submatch, regsubs_T *m) FUNC_ATTR_NONNULL_ARG(1, 2, 4);
static int nfa_regtry(nfa_regprog_T *prog, colnr_T col, proftime_T *tm, int *timed_out);
static int nfa_regexec_both(uint8_t *line, colnr_T startcol, proftime_T *tm, int *timed_out);
static regprog_T *nfa_regcomp(uint8_t *expr, int re_flags);
static void nfa_regfree(regprog_T *prog);
static int nfa_regexec_nl(regmatch_T *rmp, uint8_t *line, colnr_T col, _Bool line_lbr);
static int nfa_regexec_multi(regmmatch_T *rmp, win_T *win, buf_T *buf, linenr_T lnum, colnr_T col, proftime_T *tm, int *timed_out);
static void report_re_switch(const char *pat);
static _Bool vim_regexec_string(regmatch_T *rmp, const char *line, colnr_T col, _Bool nl);
#define DEFINE_EMPTY_ATTRIBUTES
#include "nvim/func_attr.h"  // IWYU pragma: export

