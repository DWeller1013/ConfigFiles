#define DEFINE_FUNC_ATTRIBUTES
#include "nvim/func_attr.h"
#undef DEFINE_FUNC_ATTRIBUTES
static int tslua_has_language(lua_State *L);
static int tslua_add_language_from_object(lua_State *L);
static const TSLanguage *load_language_from_object(lua_State *L, const char *path, const char *lang_name, const char *symbol);
static const TSLanguage *load_language_from_wasm(lua_State *L, const char *path, const char *lang_name);
static int add_language(lua_State *L, _Bool is_wasm);
static int tslua_remove_lang(lua_State *L);
static TSLanguage *lang_check(lua_State *L, int index);
static int tslua_inspect_lang(lua_State *L);
static int tslua_push_parser(lua_State *L);
static TSParser *parser_check(lua_State *L, uint16_t index);
static void logger_gc(TSLogger logger);
static int parser_gc(lua_State *L);
static int parser_tostring(lua_State *L);
static const char *input_cb(void *payload, uint32_t byte_index, TSPoint position, uint32_t *bytes_read);
static void push_ranges(lua_State *L, const TSRange *ranges, const size_t length, _Bool include_bytes);
static _Bool on_parser_progress(TSParseState *state);
static int parser_parse(lua_State *L);
static int parser_reset(lua_State *L);
static void range_err(lua_State *L);
static void range_from_lua(lua_State *L, TSRange *range);
static int parser_set_ranges(lua_State *L);
static int parser_get_ranges(lua_State *L);
static void logger_cb(void *payload, TSLogType logtype, const char *s);
static int parser_set_logger(lua_State *L);
static int parser_get_logger(lua_State *L);
static void push_tree(lua_State *L, TSTree *tree);
static int tree_copy(lua_State *L);
static int tree_edit(lua_State *L);
static int tree_get_ranges(lua_State *L);
static int tree_gc(lua_State *L);
static int tree_tostring(lua_State *L);
static int tree_root(lua_State *L);
static void push_node(lua_State *L, TSNode node, int uindex);
static _Bool node_check_opt(lua_State *L, int index, TSNode *res);
static TSNode node_check(lua_State *L, int index);
static int node_tostring(lua_State *L);
static int node_eq(lua_State *L);
static int node_id(lua_State *L);
static int node_range(lua_State *L);
static int node_start(lua_State *L);
static int node_end(lua_State *L);
static int node_child_count(lua_State *L);
static int node_named_child_count(lua_State *L);
static int node_type(lua_State *L);
static int node_symbol(lua_State *L);
static int node_field(lua_State *L);
static int node_named(lua_State *L);
static int node_sexpr(lua_State *L);
static int node_missing(lua_State *L);
static int node_extra(lua_State *L);
static int node_has_changes(lua_State *L);
static int node_has_error(lua_State *L);
static int node_child(lua_State *L);
static int node_named_child(lua_State *L);
static int node_descendant_for_range(lua_State *L);
static int node_named_descendant_for_range(lua_State *L);
static int node_next_child(lua_State *L);
static int node_iter_children(lua_State *L);
static int node_parent(lua_State *L);
static int __has_ancestor(lua_State *L);
static int node_child_with_descendant(lua_State *L);
static int node_next_sibling(lua_State *L);
static int node_prev_sibling(lua_State *L);
static int node_next_named_sibling(lua_State *L);
static int node_prev_named_sibling(lua_State *L);
static int node_named_children(lua_State *L);
static int node_root(lua_State *L);
static int node_tree(lua_State *L);
static int node_byte_length(lua_State *L);
static int node_equal(lua_State *L);
static int tslua_push_querycursor(lua_State *L);
static int querycursor_remove_match(lua_State *L);
static int querycursor_next_capture(lua_State *L);
static int querycursor_next_match(lua_State *L);
static TSQueryCursor *querycursor_check(lua_State *L, int index);
static int querycursor_gc(lua_State *L);
static void push_querymatch(lua_State *L, TSQueryMatch *match, int uindex);
static int querymatch_info(lua_State *L);
static int querymatch_captures(lua_State *L);
static int tslua_parse_query(lua_State *L);
static const char *query_err_to_string(TSQueryError error_type);
static void query_err_string(const char *src, int error_offset, TSQueryError error_type, char *err, size_t errlen);
static TSQuery *query_check(lua_State *L, int index);
static int query_gc(lua_State *L);
static int query_tostring(lua_State *L);
static int query_inspect(lua_State *L);
static int query_disable_capture(lua_State *L);
static int query_disable_pattern(lua_State *L);
static void build_meta(lua_State *L, const char *tname, const luaL_Reg *meta);
static void tslua_init(lua_State *L);
static int tslua_get_language_version(lua_State *L);
static int tslua_get_minimum_language_version(lua_State *L);
#define DEFINE_EMPTY_ATTRIBUTES
#include "nvim/func_attr.h"  // IWYU pragma: export

